{"version":3,"file":"1118.e564ab0a15794f9a0342.js","mappings":"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","sources":["webpack://telegram-t/./node_modules/music-metadata/lib/ogg/vorbis/VorbisStream.js","webpack://telegram-t/./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js","webpack://telegram-t/./node_modules/music-metadata/lib/ogg/opus/Opus.js","webpack://telegram-t/./node_modules/music-metadata/lib/ogg/opus/OpusStream.js","webpack://telegram-t/./node_modules/music-metadata/lib/ogg/speex/Speex.js","webpack://telegram-t/./node_modules/music-metadata/lib/ogg/speex/SpeexStream.js","webpack://telegram-t/./node_modules/music-metadata/lib/ogg/theora/Theora.js","webpack://telegram-t/./node_modules/music-metadata/lib/ogg/theora/TheoraStream.js","webpack://telegram-t/./node_modules/music-metadata/lib/ogg/OggToken.js","webpack://telegram-t/./node_modules/music-metadata/lib/ogg/OggParser.js","webpack://telegram-t/./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js"],"sourcesContent":["import * as Token from 'token-types';\nimport debugInit from 'debug';\nimport { VorbisDecoder } from './VorbisDecoder.js';\nimport { CommonHeader, IdentificationHeader, VorbisPictureToken } from './Vorbis.js';\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\nconst debug = debugInit('music-metadata:parser:ogg:vorbis1');\nexport class VorbisContentError extends makeUnexpectedFileContentError('Vorbis') {\n}\n/**\n * Vorbis 1 Parser.\n * Used by OggStream\n */\nexport class VorbisStream {\n    constructor(metadata, options) {\n        this.pageSegments = [];\n        this.metadata = metadata;\n        this.options = options;\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        this.lastPageHeader = header;\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n        else {\n            if (header.headerType.continued) {\n                if (this.pageSegments.length === 0) {\n                    throw new VorbisContentError('Cannot continue on previous page');\n                }\n                this.pageSegments.push(pageData);\n            }\n            if (header.headerType.lastPage || !header.headerType.continued) {\n                // Flush page segments\n                if (this.pageSegments.length > 0) {\n                    const fullPage = VorbisStream.mergeUint8Arrays(this.pageSegments);\n                    await this.parseFullPage(fullPage);\n                }\n                // Reset page segments\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n            }\n        }\n    }\n    static mergeUint8Arrays(arrays) {\n        const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);\n        const merged = new Uint8Array(totalSize);\n        arrays.forEach((array, i, _arrays) => {\n            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);\n            merged.set(array, offset);\n        });\n        return merged;\n    }\n    async flush() {\n        await this.parseFullPage(VorbisStream.mergeUint8Arrays(this.pageSegments));\n    }\n    async parseUserComment(pageData, offset) {\n        const decoder = new VorbisDecoder(pageData, offset);\n        const tag = decoder.parseUserComment();\n        await this.addTag(tag.key, tag.value);\n        return tag.len;\n    }\n    async addTag(id, value) {\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\n            if (this.options.skipCovers) {\n                debug(\"Ignore picture\");\n                return;\n            }\n            value = VorbisPictureToken.fromBase64(value);\n            debug(`Push picture: id=${id}, format=${value.format}`);\n        }\n        else {\n            debug(`Push tag: id=${id}, value=${value}`);\n        }\n        await this.metadata.addTag('vorbis', id, value);\n    }\n    calculateDuration() {\n        if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            this.metadata.setFormat('numberOfSamples', this.lastPageHeader.absoluteGranulePosition);\n            this.metadata.setFormat('duration', this.lastPageHeader.absoluteGranulePosition / this.metadata.format.sampleRate);\n        }\n    }\n    /**\n     * Parse first Ogg/Vorbis page\n     * @param header\n     * @param pageData\n     */\n    parseFirstPage(_header, pageData) {\n        this.metadata.setFormat('codec', 'Vorbis I');\n        this.metadata.setFormat('hasAudio', true);\n        debug('Parse first page');\n        // Parse  Vorbis common header\n        const commonHeader = CommonHeader.get(pageData, 0);\n        if (commonHeader.vorbis !== 'vorbis')\n            throw new VorbisContentError('Metadata does not look like Vorbis');\n        if (commonHeader.packetType === 1) {\n            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n            debug('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n        }\n        else\n            throw new VorbisContentError('First Ogg page should be type 1: the identification header');\n    }\n    async parseFullPage(pageData) {\n        // New page\n        const commonHeader = CommonHeader.get(pageData, 0);\n        debug('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);\n        switch (commonHeader.packetType) {\n            case 3: //  type 3: comment header\n                return this.parseUserCommentList(pageData, CommonHeader.len);\n            case 1: // type 1: the identification header\n            case 5: // type 5: setup header type\n                break; // ignore\n        }\n    }\n    /**\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n     */\n    async parseUserCommentList(pageData, offset) {\n        const strLen = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n        offset += strLen;\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        while (userCommentListLength-- > 0) {\n            offset += (await this.parseUserComment(pageData, offset));\n        }\n    }\n}\n//# sourceMappingURL=VorbisStream.js.map","import * as Token from 'token-types';\nexport class VorbisDecoder {\n    constructor(data, offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n    readInt32() {\n        const value = Token.UINT32_LE.get(this.data, this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readStringUtf8() {\n        const len = this.readInt32();\n        const value = new TextDecoder('utf-8').decode(this.data.subarray(this.offset, this.offset + len));\n        this.offset += len;\n        return value;\n    }\n    parseUserComment() {\n        const offset0 = this.offset;\n        const v = this.readStringUtf8();\n        const idx = v.indexOf('=');\n        return {\n            key: v.slice(0, idx).toUpperCase(),\n            value: v.slice(idx + 1),\n            len: this.offset - offset0\n        };\n    }\n}\n//# sourceMappingURL=VorbisDecoder.js.map","import * as Token from 'token-types';\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\nexport class OpusContentError extends makeUnexpectedFileContentError('Opus') {\n}\n/**\n * Opus ID Header parser\n * Ref: https://wiki.xiph.org/OggOpus#ID_Header\n */\nexport class IdHeader {\n    constructor(len) {\n        if (len < 19) {\n            throw new OpusContentError('ID-header-page 0 should be at least 19 bytes long');\n        }\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            magicSignature: new Token.StringType(8, 'ascii').get(buf, off + 0),\n            version: Token.UINT8.get(buf, off + 8),\n            channelCount: Token.UINT8.get(buf, off + 9),\n            preSkip: Token.UINT16_LE.get(buf, off + 10),\n            inputSampleRate: Token.UINT32_LE.get(buf, off + 12),\n            outputGain: Token.UINT16_LE.get(buf, off + 16),\n            channelMapping: Token.UINT8.get(buf, off + 18)\n        };\n    }\n}\n//# sourceMappingURL=Opus.js.map","import * as Token from 'token-types';\nimport { VorbisStream } from '../vorbis/VorbisStream.js';\nimport * as Opus from './Opus.js';\nimport { OpusContentError } from './Opus.js';\n/**\n * Opus parser\n * Internet Engineering Task Force (IETF) - RFC 6716\n * Used by OggStream\n */\nexport class OpusStream extends VorbisStream {\n    constructor(metadata, options, tokenizer) {\n        super(metadata, options);\n        this.idHeader = null;\n        this.lastPos = -1;\n        this.tokenizer = tokenizer;\n    }\n    /**\n     * Parse first Opus Ogg page\n     * @param {IPageHeader} header\n     * @param {Uint8Array} pageData\n     */\n    parseFirstPage(_header, pageData) {\n        this.metadata.setFormat('codec', 'Opus');\n        // Parse Opus ID Header\n        this.idHeader = new Opus.IdHeader(pageData.length).get(pageData, 0);\n        if (this.idHeader.magicSignature !== \"OpusHead\")\n            throw new OpusContentError(\"Illegal ogg/Opus magic-signature\");\n        this.metadata.setFormat('sampleRate', this.idHeader.inputSampleRate);\n        this.metadata.setFormat('numberOfChannels', this.idHeader.channelCount);\n        this.metadata.setAudioOnly();\n    }\n    async parseFullPage(pageData) {\n        const magicSignature = new Token.StringType(8, 'ascii').get(pageData, 0);\n        switch (magicSignature) {\n            case 'OpusTags':\n                await this.parseUserCommentList(pageData, 8);\n                this.lastPos = this.tokenizer.position - pageData.length;\n                break;\n            default:\n                break;\n        }\n    }\n    calculateDuration() {\n        if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            const pos_48bit = this.lastPageHeader.absoluteGranulePosition - this.idHeader.preSkip;\n            this.metadata.setFormat('numberOfSamples', pos_48bit);\n            this.metadata.setFormat('duration', pos_48bit / 48000);\n            if (this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n                const dataSize = this.tokenizer.fileInfo.size - this.lastPos;\n                this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n            }\n        }\n    }\n}\n//# sourceMappingURL=OpusStream.js.map","import * as Token from 'token-types';\nimport * as util from '../../common/Util.js';\n/**\n * Speex Header Packet\n * Ref: https://www.speex.org/docs/manual/speex-manual/node8.html#SECTION00830000000000000000\n */\nexport const Header = {\n    len: 80,\n    get: (buf, off) => {\n        return {\n            speex: new Token.StringType(8, 'ascii').get(buf, off + 0),\n            version: util.trimRightNull(new Token.StringType(20, 'ascii').get(buf, off + 8)),\n            version_id: Token.INT32_LE.get(buf, off + 28),\n            header_size: Token.INT32_LE.get(buf, off + 32),\n            rate: Token.INT32_LE.get(buf, off + 36),\n            mode: Token.INT32_LE.get(buf, off + 40),\n            mode_bitstream_version: Token.INT32_LE.get(buf, off + 44),\n            nb_channels: Token.INT32_LE.get(buf, off + 48),\n            bitrate: Token.INT32_LE.get(buf, off + 52),\n            frame_size: Token.INT32_LE.get(buf, off + 56),\n            vbr: Token.INT32_LE.get(buf, off + 60),\n            frames_per_packet: Token.INT32_LE.get(buf, off + 64),\n            extra_headers: Token.INT32_LE.get(buf, off + 68),\n            reserved1: Token.INT32_LE.get(buf, off + 72),\n            reserved2: Token.INT32_LE.get(buf, off + 76)\n        };\n    }\n};\n//# sourceMappingURL=Speex.js.map","import initDebug from 'debug';\nimport { VorbisStream } from '../vorbis/VorbisStream.js';\nimport * as Speex from './Speex.js';\nconst debug = initDebug('music-metadata:parser:ogg:speex');\n/**\n * Speex, RFC 5574\n * Ref:\n * - https://www.speex.org/docs/manual/speex-manual/\n * - https://tools.ietf.org/html/rfc5574\n */\nexport class SpeexStream extends VorbisStream {\n    constructor(metadata, options, tokenizer) {\n        super(metadata, options);\n        this.tokenizer = tokenizer;\n    }\n    /**\n     * Parse first Speex Ogg page\n     * @param {IPageHeader} header\n     * @param {Uint8Array} pageData\n     */\n    parseFirstPage(_header, pageData) {\n        debug('First Ogg/Speex page');\n        const speexHeader = Speex.Header.get(pageData, 0);\n        this.metadata.setFormat('codec', `Speex ${speexHeader.version}`);\n        this.metadata.setFormat('numberOfChannels', speexHeader.nb_channels);\n        this.metadata.setFormat('sampleRate', speexHeader.rate);\n        if (speexHeader.bitrate !== -1) {\n            this.metadata.setFormat('bitrate', speexHeader.bitrate);\n        }\n        this.metadata.setAudioOnly();\n    }\n}\n//# sourceMappingURL=SpeexStream.js.map","import * as Token from 'token-types';\n/**\n * 6.2 Identification Header\n * Ref: https://theora.org/doc/Theora.pdf: 6.2 Identification Header Decode\n */\nexport const IdentificationHeader = {\n    len: 42,\n    get: (buf, off) => {\n        return {\n            id: new Token.StringType(7, 'ascii').get(buf, off),\n            vmaj: Token.UINT8.get(buf, off + 7),\n            vmin: Token.UINT8.get(buf, off + 8),\n            vrev: Token.UINT8.get(buf, off + 9),\n            vmbw: Token.UINT16_BE.get(buf, off + 10),\n            vmbh: Token.UINT16_BE.get(buf, off + 17),\n            nombr: Token.UINT24_BE.get(buf, off + 37),\n            nqual: Token.UINT8.get(buf, off + 40)\n        };\n    }\n};\n//# sourceMappingURL=Theora.js.map","import initDebug from 'debug';\nimport { IdentificationHeader } from './Theora.js';\nconst debug = initDebug('music-metadata:parser:ogg:theora');\n/**\n * Ref:\n * - https://theora.org/doc/Theora.pdf\n */\nexport class TheoraStream {\n    constructor(metadata, _options, tokenizer) {\n        this.metadata = metadata;\n        this.tokenizer = tokenizer;\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            await this.parseFirstPage(header, pageData);\n        }\n    }\n    calculateDuration() {\n        debug('duration calculation not implemented');\n    }\n    /**\n     * Parse first Theora Ogg page. the initial identification header packet\n     */\n    async parseFirstPage(_header, pageData) {\n        debug('First Ogg/Theora page');\n        this.metadata.setFormat('codec', 'Theora');\n        const idHeader = IdentificationHeader.get(pageData, 0);\n        this.metadata.setFormat('bitrate', idHeader.nombr);\n        this.metadata.setFormat('hasVideo', true);\n    }\n    flush() {\n        return Promise.resolve();\n    }\n}\n//# sourceMappingURL=TheoraStream.js.map","import * as Token from 'token-types';\nimport * as util from '../common/Util.js';\nimport { StringType } from 'token-types';\nexport const PageHeader = {\n    len: 27,\n    get: (buf, off) => {\n        return {\n            capturePattern: new StringType(4, 'latin1').get(buf, off),\n            version: Token.UINT8.get(buf, off + 4),\n            headerType: {\n                continued: util.getBit(buf, off + 5, 0),\n                firstPage: util.getBit(buf, off + 5, 1),\n                lastPage: util.getBit(buf, off + 5, 2)\n            },\n            // packet_flag: Token.UINT8.get(buf, off + 5),\n            absoluteGranulePosition: Number(Token.UINT64_LE.get(buf, off + 6)),\n            streamSerialNumber: Token.UINT32_LE.get(buf, off + 14),\n            pageSequenceNo: Token.UINT32_LE.get(buf, off + 18),\n            pageChecksum: Token.UINT32_LE.get(buf, off + 22),\n            page_segments: Token.UINT8.get(buf, off + 26)\n        };\n    }\n};\nexport class SegmentTable {\n    static sum(buf, off, len) {\n        const dv = new DataView(buf.buffer, 0);\n        let s = 0;\n        for (let i = off; i < off + len; ++i) {\n            s += dv.getUint8(i);\n        }\n        return s;\n    }\n    constructor(header) {\n        this.len = header.page_segments;\n    }\n    get(buf, off) {\n        return {\n            totalPageSize: SegmentTable.sum(buf, off, this.len)\n        };\n    }\n}\n//# sourceMappingURL=OggToken.js.map","import * as Token from 'token-types';\nimport { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { VorbisStream } from './vorbis/VorbisStream.js';\nimport { OpusStream } from './opus/OpusStream.js';\nimport { SpeexStream } from './speex/SpeexStream.js';\nimport { TheoraStream } from './theora/TheoraStream.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport { PageHeader, SegmentTable } from './OggToken.js';\nexport class OggContentError extends makeUnexpectedFileContentError('Ogg') {\n}\nconst debug = initDebug('music-metadata:parser:ogg');\nclass OggStream {\n    constructor(metadata, streamSerial, options) {\n        this.pageNumber = 0;\n        this.closed = false;\n        this.metadata = metadata;\n        this.streamSerial = streamSerial;\n        this.options = options;\n    }\n    async parsePage(tokenizer, header) {\n        this.pageNumber = header.pageSequenceNo;\n        debug('serial=%s page#=%s, Ogg.id=%s', header.streamSerialNumber, header.pageSequenceNo, header.capturePattern);\n        const segmentTable = await tokenizer.readToken(new SegmentTable(header));\n        debug('totalPageSize=%s', segmentTable.totalPageSize);\n        const pageData = await tokenizer.readToken(new Token.Uint8ArrayType(segmentTable.totalPageSize));\n        debug('firstPage=%s, lastPage=%s, continued=%s', header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);\n        if (header.headerType.firstPage) {\n            const idData = pageData.slice(0, 7); // Copy this portion\n            switch (idData[0]) {\n                case 0x01:\n                case 0x80:\n                    idData[0] = 0x5F; // underscore\n                    break;\n            }\n            const id = new TextDecoder('latin1').decode(idData);\n            switch (id) {\n                case '_vorbis': // Ogg/Vorbis\n                    debug(`Set Ogg stream serial ${header.streamSerialNumber}, codec=Vorbis`);\n                    this.pageConsumer = new VorbisStream(this.metadata, this.options);\n                    break;\n                case 'OpusHea': // Ogg/Opus\n                    debug('Set page consumer to Ogg/Opus');\n                    this.pageConsumer = new OpusStream(this.metadata, this.options, tokenizer);\n                    break;\n                case 'Speex  ': // Ogg/Speex\n                    debug('Set page consumer to Ogg/Speex');\n                    this.pageConsumer = new SpeexStream(this.metadata, this.options, tokenizer);\n                    break;\n                case 'fishead':\n                case '_theora': // Ogg/Theora\n                    debug('Set page consumer to Ogg/Theora');\n                    this.pageConsumer = new TheoraStream(this.metadata, this.options, tokenizer);\n                    break;\n                default:\n                    throw new OggContentError(`Ogg codec not recognized (id=${id})`);\n            }\n        }\n        if (header.headerType.lastPage) {\n            this.closed = true;\n        }\n        if (this.pageConsumer) {\n            await this.pageConsumer.parsePage(header, pageData);\n        }\n        else\n            throw new Error('pageConsumer should be initialized');\n    }\n}\n/**\n * Parser for Ogg logical bitstream framing\n */\nexport class OggParser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.streams = new Map();\n    }\n    /**\n     * Parse page\n     * @returns {Promise<void>}\n     */\n    async parse() {\n        this.streams = new Map();\n        debug('pos=%s, parsePage()', this.tokenizer.position);\n        let header;\n        try {\n            do {\n                header = await this.tokenizer.readToken(PageHeader);\n                if (header.capturePattern !== 'OggS')\n                    throw new OggContentError('Invalid Ogg capture pattern');\n                this.metadata.setFormat('container', 'Ogg');\n                let stream = this.streams.get(header.streamSerialNumber);\n                if (!stream) {\n                    stream = new OggStream(this.metadata, header.streamSerialNumber, this.options);\n                    this.streams.set(header.streamSerialNumber, stream);\n                }\n                await stream.parsePage(this.tokenizer, header);\n            } while (![...this.streams.values()].every(item => item.closed));\n        }\n        catch (err) {\n            if (err instanceof EndOfStreamError) {\n                debug(\"Reached end-of-stream\");\n            }\n            else if (err instanceof OggContentError) {\n                this.metadata.addWarning(`Corrupt Ogg content at ${this.tokenizer.position}`);\n            }\n            else\n                throw err;\n        }\n        for (const stream of this.streams.values()) {\n            if (!stream.closed) {\n                this.metadata.addWarning(`End-of-stream reached before reaching last page in Ogg stream serial=${stream.streamSerial}`);\n                await stream.pageConsumer?.flush();\n            }\n            stream.pageConsumer?.calculateDuration();\n        }\n    }\n}\n//# sourceMappingURL=OggParser.js.map","import * as Token from 'token-types';\nimport { AttachedPictureType } from '../../id3v2/ID3v2Token.js';\n/**\n * Parse the METADATA_BLOCK_PICTURE\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\n * // ToDo: move to ID3 / APIC?\n */\nexport class VorbisPictureToken {\n    static fromBase64(base64str) {\n        return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), c => c.charCodeAt(0)));\n    }\n    static fromBuffer(buffer) {\n        const pic = new VorbisPictureToken(buffer.length);\n        return pic.get(buffer, 0);\n    }\n    constructor(len) {\n        this.len = len;\n    }\n    get(buffer, offset) {\n        const type = AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];\n        offset += 4;\n        const mimeLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const format = new Token.StringType(mimeLen, 'utf-8').get(buffer, offset);\n        offset += mimeLen;\n        const descLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const description = new Token.StringType(descLen, 'utf-8').get(buffer, offset);\n        offset += descLen;\n        const width = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const height = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const colour_depth = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const indexed_color = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const picDataLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const data = Uint8Array.from(buffer.slice(offset, offset + picDataLen));\n        return {\n            type,\n            format,\n            description,\n            width,\n            height,\n            colour_depth,\n            indexed_color,\n            data\n        };\n    }\n}\n/**\n * Comment header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\n */\nexport const CommonHeader = {\n    len: 7,\n    get: (buf, off) => {\n        return {\n            packetType: Token.UINT8.get(buf, off),\n            vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)\n        };\n    }\n};\n/**\n * Identification header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\n */\nexport const IdentificationHeader = {\n    len: 23,\n    get: (uint8Array, off) => {\n        return {\n            version: Token.UINT32_LE.get(uint8Array, off + 0),\n            channelMode: Token.UINT8.get(uint8Array, off + 4),\n            sampleRate: Token.UINT32_LE.get(uint8Array, off + 5),\n            bitrateMax: Token.UINT32_LE.get(uint8Array, off + 9),\n            bitrateNominal: Token.UINT32_LE.get(uint8Array, off + 13),\n            bitrateMin: Token.UINT32_LE.get(uint8Array, off + 17)\n        };\n    }\n};\n//# sourceMappingURL=Vorbis.js.map"],"names":["debug","VorbisContentError","VorbisStream","constructor","metadata","options","this","pageSegments","parsePage","header","pageData","lastPageHeader","headerType","firstPage","parseFirstPage","continued","length","push","lastPage","fullPage","mergeUint8Arrays","parseFullPage","arrays","totalSize","reduce","acc","e","merged","Uint8Array","forEach","array","i","_arrays","offset","slice","set","flush","parseUserComment","tag","addTag","key","value","len","id","skipCovers","fromBase64","format","calculateDuration","sampleRate","absoluteGranulePosition","setFormat","_header","commonHeader","get","vorbis","packetType","idHeader","bitrateNominal","channelMode","byteLength","parseUserCommentList","strLen","userCommentListLength","VorbisDecoder","data","readInt32","readStringUtf8","TextDecoder","decode","subarray","offset0","v","idx","indexOf","toUpperCase","OpusContentError","IdHeader","buf","off","magicSignature","version","channelCount","preSkip","inputSampleRate","outputGain","channelMapping","OpusStream","tokenizer","super","lastPos","setAudioOnly","position","pos_48bit","fileInfo","size","duration","dataSize","SpeexStream","speexHeader","speex","version_id","header_size","rate","mode","mode_bitstream_version","nb_channels","bitrate","frame_size","vbr","frames_per_packet","extra_headers","reserved1","reserved2","TheoraStream","_options","vmaj","vmin","vrev","vmbw","vmbh","nombr","nqual","Promise","resolve","PageHeader","capturePattern","StringType","Number","streamSerialNumber","pageSequenceNo","pageChecksum","page_segments","SegmentTable","sum","dv","DataView","buffer","s","getUint8","totalPageSize","OggContentError","OggStream","streamSerial","pageNumber","closed","segmentTable","readToken","idData","pageConsumer","Error","OggParser","BasicParser","arguments","streams","Map","parse","stream","values","every","item","err","addWarning","VorbisPictureToken","base64str","fromBuffer","from","atob","c","charCodeAt","type","mimeLen","descLen","description","width","height","colour_depth","indexed_color","picDataLen","CommonHeader","IdentificationHeader","uint8Array","bitrateMax","bitrateMin"],"sourceRoot":""}